{
    "sourceFile": "src/tests/test_unit_api.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748000947623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748000947623,
            "name": "Commit-0",
            "content": "\n\nimport pytest\nfrom flask import Flask\nfrom unittest.mock import MagicMock\nfrom src.api import app, loaded_pipeline, load_artifacts # Importer les objets directement\n\n# Utiliser le client de test de Flask pour simuler des requêtes à l'API\n@pytest.fixture\ndef client():\n    with app.test_client() as client:\n        yield client\n\n# Tests pour vérifier que la piepline contenant le modèle est bien chargée\ndef test_load_artifacts_success(monkeypatch):\n    # Mock le chargement du modèle pour simuler un succès\n    def mock_load_model(path):\n        return \"mock_pipeline\"\n    monkeypatch.setattr('src.api.sklearn.load_model', mock_load_model)\n    pipeline = load_artifacts()\n    assert pipeline == \"mock_pipeline\"\n\ndef test_load_artifacts_failure(monkeypatch):\n    # Mock le chargement du modèle pour simuler un échec\n    def mock_load_model(path):\n        raise Exception(\"Erreur simulée\")\n    monkeypatch.setattr('src.api.sklearn.load_model', mock_load_model)\n    pipeline = load_artifacts()\n    assert pipeline is None\n    \n# Test pour vérifier que l'API retourne une réponse correcte pour le point d'entrée racine\ndef test_home(client):\n    response = client.get('/')\n    assert response.status_code == 200\n    assert \"L'API est en cours d'exécution\".encode('utf-8') in response.data\n\n# Test pour vérifier que l'API retourne une prédiction valide pour un texte positif\ndef test_predict_positive(client, monkeypatch):\n    monkeypatch.setattr('src.api.loaded_pipeline', MagicMock(predict=lambda x: [1]))\n    response = client.post('/predict', json={'text': 'Je suis tellement heureux aujourd\\'hui!'})\n    json_data = response.get_json()\n    assert response.status_code == 200\n    assert 'predictions' in json_data\n    assert isinstance(json_data['predictions'], list)  # Vérifie que les prédictions sont sous forme de liste\n\n# Test pour vérifier que l'API retourne une prédiction valide pour un texte négatif\ndef test_predict_negative(client, monkeypatch):\n    monkeypatch.setattr('src.api.loaded_pipeline', MagicMock(predict=lambda x: [0]))\n    response = client.post('/predict', json={'text': 'Je suis très triste et déçu.'})\n    json_data = response.get_json()\n    assert response.status_code == 200\n    assert 'predictions' in json_data\n    assert isinstance(json_data['predictions'], list)\n\n# Test pour vérifier que l'API retourne une erreur si le champ \"text\" est manquant\ndef test_missing_text_field(client, monkeypatch):\n    monkeypatch.setattr('src.api.loaded_pipeline', MagicMock(predict=lambda x: [1]))\n    response = client.post('/predict', json={})\n    json_data = response.get_json()\n    assert response.status_code == 400\n    assert 'error' in json_data\n    assert json_data['error'] == 'Le champ \"text\" est manquant dans la requête'\n\n# Test pour vérifier le comportement si le modèle ou le vectorizer ne sont pas chargés\ndef test_predict_model_not_loaded(client, monkeypatch):\n    monkeypatch.setattr('src.api.loaded_pipeline', None)\n    response = client.post('/predict', json={'text': 'Test de texte'})\n    json_data = response.get_json()\n    assert response.status_code == 500\n    assert 'error' in json_data\n    assert json_data['error'] == \"La pipeline n'a pas pu être chargée pour la prédiction\"\n\n# Test pour vérifier que l'API gère correctement une exception pendant la prédiction\ndef test_predict_exception(client, monkeypatch):\n    # On mock la méthode predict de la pipeline pour simuler une erreur\n    def mock_predict(data):\n        raise Exception(\"Erreur dans predict\")\n\n    monkeypatch.setattr('src.api.loaded_pipeline', MagicMock())\n    monkeypatch.setattr('src.api.loaded_pipeline.predict', mock_predict)\n    response = client.post('/predict', json={'text': 'Test de texte'})\n    json_data = response.get_json()\n    assert response.status_code == 400\n    assert 'error' in json_data\n    assert json_data['error'] == \"Erreur dans predict\"\n\n# Test pour le point d'entrée feedback - cas valide\ndef test_feedback_valid(client):\n    response = client.post('/feedback', json={\n        \"text\": \"Ceci est un texte\",\n        \"prediction\": \"positif\",\n        \"feedback\": \"valide\"\n    })\n    json_data = response.get_json()\n    assert response.status_code == 200\n    assert 'status' in json_data\n    assert json_data['status'] == 'Feedback reçu'\n\n# Test pour le point d'entrée feedback - cas de requête invalide\ndef test_feedback_invalid_request(client):\n    response = client.post('/feedback', json={})\n    json_data = response.get_json()\n    assert response.status_code == 400\n    assert 'error' in json_data\n    assert json_data['error'] == 'Requête invalide'\n\n# Test pour vérifier les logs dans le feedback - non valide\ndef test_feedback_log_non_valide(client, monkeypatch):\n    mock_logger = MagicMock()\n    monkeypatch.setattr('src.api.logger', mock_logger)\n\n    client.post('/feedback', json={\n        \"text\": \"Ceci est un texte\",\n        \"prediction\": \"positif\",\n        \"feedback\": \"non_valide\"\n    })\n\n    mock_logger.warning.assert_called_once_with(\n        \"Prédiction incorrecte\",\n        extra={\"custom_dimensions\": {\"tweet\": \"Ceci est un texte\", \"prediction\": \"positif\"}}\n    )\n\n# Test pour vérifier les logs dans le feedback - valide\ndef test_feedback_log_valide(client, monkeypatch):\n    mock_logger = MagicMock()\n    monkeypatch.setattr('src.api.logger', mock_logger)\n\n    client.post('/feedback', json={\n        \"text\": \"Ceci est un texte\",\n        \"prediction\": \"positif\",\n        \"feedback\": \"valide\"\n    })\n\n    mock_logger.info.assert_called_once_with(\n        \"Prédiction validée\",\n        extra={\"custom_dimensions\": {\"tweet\": \"Ceci est un texte\", \"prediction\": \"positif\"}}\n    )\n"
        }
    ]
}